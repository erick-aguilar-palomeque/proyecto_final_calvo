--PL QUE TE DICE SI HAY REACTIVOS Y MATERIALES SUFICIENTES PARA REALIZAR EL ANALISIS
create or replace function ver_si_hay_recursos_para_analisis(fnum_a int)
returns int
as 
$$ 

declare
    material record;
    atributo record;
    reactivo record;
    devolver int := 2;
    comodin int;

begin

    for material in (select det_a_materiales.*, materiales.nom_m, materiales.stock_actual_m from det_a_materiales inner join materiales on 
    det_a_materiales.codi_barra_m=materiales.codi_barra_m and det_a_materiales.num_a = fnum_a)
    loop

        if material.stock_actual_m >= material.cant_ocupada_m then
            comodin = 1;
            devolver = 1;
        else
            devolver = 0;
            comodin = 0;
        end if;

        if comodin = 0 then
            exit;
        end if;

        --raise notice 'num_a: % cons: % cod: % cant: % nom: % stock: %',material.num_a, material.cons_det_a_materiales, material.codi_barra_m, material.cant_ocupada_m, material.nom_m, material.stock_actual_m;

    end loop;

    if devolver = 1 then
        comodin:=2;
        for atributo in (select * from det_a_atributos where num_a = fnum_a)    
        loop
            --raise notice 'NUEVO ATRIBUTO';
            --raise notice ' ';


            for reactivo in (select det_atributos.*, reactivos.nom_r, reactivos.stock_actual_r from det_atributos inner join reactivos on det_atributos.codi_barra_r = reactivos.codi_barra_r and det_atributos.num_atri = atributo.num_atri) 
            loop

                --raise notice 'num_atri: % cant: % nom: % stock: %',reactivo.num_atri,reactivo.cant_ocupada_r, reactivo.nom_r, reactivo.stock_actual_r;
                --raise notice '  ';

                if reactivo.stock_actual_r >= reactivo.cant_ocupada_r then
                    comodin = 1;
                    devolver = 1;
                else
                    comodin = 0;
                    devolver = 0;
                end if;

                if comodin = 0 then
                    exit;
                end if;
            end loop;

        if comodin = 0 then
            exit;
        end if;

        end loop;        
    end if;

    



    return devolver;
end;

$$
Language plpgsql;



--PL QUE INSERTA LOS INVENTARIOS RECIEN SOLICITAS UN ANALISIS
create or replace function inserta_inventarios(ffolio_a int, fnum_a int)
returns void
as
$$

declare
    material record;
    atributo record;
    reactivo record;
    cant_ocupada_m int;
    cant_ocupada_r float;
    stock_antes_m int;
    stock_antes_r float;

begin

    for material in (select det_a_materiales.*, materiales.* from det_a_materiales inner join materiales on 
    det_a_materiales.codi_barra_m=materiales.codi_barra_m and det_a_materiales.num_a = fnum_a)
    loop
        insert into inventario_materiales (codi_barra_m, stock_anterior_m, stock_despues_m, cant_ocupada_m, folio_a) values(material.codi_barra_m, material.stock_actual_m, material.stock_actual_m - material.cant_ocupada_m, material.cant_ocupada_m, ffolio_a);
    end loop;

    for atributo in (select * from det_a_atributos where num_a = fnum_a)    
    loop

        for reactivo in (select det_atributos.*, reactivos.* from det_atributos inner join reactivos on det_atributos.codi_barra_r = reactivos.codi_barra_r and det_atributos.num_atri = atributo.num_atri) 
        loop
        insert into inventario_reactivos (codi_barra_r, stock_anterior_r, stock_despues_r, cant_ocupada_r, folio_a) values(reactivo.codi_barra_r, reactivo.stock_actual_r, reactivo.stock_actual_r - reactivo.cant_ocupada_r, reactivo.cant_ocupada_r, ffolio_a);

        end loop;
    end loop;

end;

$$
Language plpgsql;


--PL QUE FUNCIONA CON EL TRIGGER TR_ACTUALIZAR_STOCK_M

create or replace function f_actualizar_stock_m()
returns trigger 
as
$$

declare 
    nuevo_stock int = new.stock_despues_m;
begin

    update materiales set stock_actual_m = nuevo_stock where codi_barra_m = new.codi_barra_m;
    return new;
end;

$$
Language plpgsql;






create trigger tr_actualizar_stock_m before insert on inventario_materiales
for each row 
execute procedure f_actualizar_stock_m();



--PL QUE FUNCIONA CON EL TRIGGER TR_ACTUALIZAR_STOCK_R

create or replace function f_actualizar_stock_r()
returns trigger 
as
$$

declare 
    nuevo_stock float = new.stock_despues_r;
begin

    update reactivos set stock_actual_r = nuevo_stock where codi_barra_r = new.codi_barra_r;
    return new;
end;

$$
Language plpgsql;







create trigger tr_actualizar_stock_r before insert on inventario_reactivos
for each row 
execute procedure f_actualizar_stock_r();


--PL QUE RETORNA 1 SI UN ANALISIS SE PUEDE DAR DE BAJA O 0 SI NO SE PUEDE, SE PUEDE DAR DE BAJA SOLO SI SE HAN ENTREGADO TODOS LOS ANALISIS

create or replace function f_baja_analisis(fnum_a int)
returns int 
as
$$

declare
    n_analisis_totales int := (select count(folio_a) from historial_clinico where num_a = fnum_a);
    n_analisis_entregados int := (select count(folio_a) from historial_clinico where status = 3 and num_a = fnum_a);
    devolver int;
begin

    if n_analisis_totales = n_analisis_entregados then
        devolver = 1;
        update analisis set estado_a = false where num_a = fnum_a;
    else
        devolver = 0;
    end if;



    return devolver;

end;

$$
Language plpgsql;





--PL QUE FUNCIONA CON TRIGGER TR_UPDATE_HISTORIAL, INSERTA LAS FECHAS DE REALIZACION Y DE ENTREGADO

create or replace function f_insertar_fechas_historial()
returns trigger 
as
$$

declare

begin

    if new.status = 2 then
        new.fecha_realizacion := now(); 
    end if;

    if new.status = 3 then
        new.fecha_entrega := now(); 
    end if;


return new;
end;

$$
Language plpgsql;











create trigger tr_update_historial before update on historial_clinico
for each row 
execute procedure f_insertar_fechas_historial(); 


--PL QUE RETORNA 1 SI SE PUEDE DAR DE BAJA UN LABORATORISTA Y 0 SI NO SE PUEDE, SE PUEDE SIEMPRE Y CUANDO EL LABORATORISTA NO ESTE INVOLUCRADO EN UN ANALISIS SOLICITADO

create or replace function f_baja_laboratoristas(fcedula_lab text)
returns int
as
$$

declare 
    devolver int;
    n_analisis_solicitados int := (select count(folio_a) from historial_clinico where status = 1 and cedula_lab = fcedula_lab);

begin
    --raise notice 'n: %',n_analisis_solicitados;
    if n_analisis_solicitados = 0 then
        devolver = 1;
        update laboratoristas set estado_lab = false where cedula_lab = fcedula_lab;
    else
        devolver = 0;
    end if;

    return devolver;
end;

$$
Language plpgsql;








--PL QUE REGRESA 1 SI SE PUEDE DAR DE BAJA UN MATERIAL Y 0 SI NO SE PUEDE, SE PUEDE CUANDO NINGUN ANALISIS DISPONIBLE LO UTILIZA

create or replace function f_baja_materiales(fcodi_barra_m int)
returns int 
as
$$

declare
    --n_materiales tiene el numero de veces que ese material se esta utilizando en los analisis disponibles
    n_materiales int:=(select count(d.codi_barra_m) from det_a_materiales d inner join analisis a on a.num_a = d.num_a and d.codi_barra_m = fcodi_barra_m and a.estado_a = true);
    devolver int;

begin

    if n_materiales = 0 then
        devolver = 1;
        update materiales set estado_m = false where codi_barra_m = fcodi_barra_m;
    else    
        devolver = 0;

    end if;

    return devolver;
end;


$$
Language plpgsql;



--PL QUE DEVUELVE 1 SI EL REACTIVO PUEDE SER ELIMINADO Y 0 SI NO, SE PUEDE ELIMINAR CUANDO NO SE ESTE USANDO EN ALGUN ATRIBUTO DISPONIBLE

create or replace function f_baja_reactivos(fcodi_barra_r int)
returns int
as
$$

declare
    n_reactivos int := (select count(da.codi_barra_r) from det_atributos da inner join atributos a on da.num_atri = a.num_atri and da.codi_barra_r = fcodi_barra_r and a.estado_atri = true);
    devolver int;

begin
    if n_reactivos = 0 then
        devolver = 1;
        update reactivos set estado_r = false where codi_barra_r = fcodi_barra_r;
    else    
        devolver = 0;

    end if;

    return devolver;


end;
$$
Language plpgsql;



--PL QUE DEVUELVE 1 SI EL ATRIBUTO PUEDE SER ELIMINADO Y 0 SI NO, SE PUEDE ELIMINAR CUANDO YA NO ES UTILIZADO EN NINGUN ANALISIS DISPONIBLE

create or replace function f_baja_atributos(fnum_atri int)
returns int
as 
$$

declare
    n_atributos int := (select count(d.num_atri) from det_a_atributos d inner join analisis a on a.num_a = d.num_a and d.num_atri = fnum_atri and a.estado_a = true);
    devolver int;
begin
    if n_atributos = 0 then
        devolver = 1;
        update atributos set estado_atri = false where num_atri = fnum_atri;
    else    
        devolver = 0;

    end if;

    return devolver;

end;
$$
Language plpgsql;